Run python -m pytest tests -q
EEEEEEEEEEEEE..EEF.....FFF.FFFFFFFFFFFFFFFFFFF                           [100%]
==================================== ERRORS ====================================
_________ ERROR at setup of test_ai_rules_crud_admin_only_and_feedback _________

db_session = <sqlalchemy.orm.session.Session object at 0x7f890a916cc0>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f89097841a0>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
_____________________ ERROR at setup of test_login_and_me ______________________

db_session = <sqlalchemy.orm.session.Session object at 0x7f89097864e0>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f8909786570>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
_________ ERROR at setup of test_escalation_runs_via_background_tasks __________

db_session = <sqlalchemy.orm.session.Session object at 0x7f8909787950>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f8909787bf0>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
___________ ERROR at setup of test_event_triggers_ai_and_notify_log ____________

db_session = <sqlalchemy.orm.session.Session object at 0x7f8909786c00>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f8909787c50>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
_____ ERROR at setup of TestFileMonitorService.test_service_initialization _____

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f89097608f0>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097abb60>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
_______ ERROR at setup of TestFileMonitorService.test_service_start_stop _______

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909760530>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097aa060>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
____ ERROR at setup of TestFileMonitorService.test_add_folder_to_monitoring ____

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f89097619d0>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097ab620>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
_ ERROR at setup of TestFileMonitorService.test_remove_folder_from_monitoring __

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909761130>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097ac6e0>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
__ ERROR at setup of TestFileMonitorService.test_file_create_event_detection ___

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f89097607a0>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097acdd0>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
__ ERROR at setup of TestFileMonitorService.test_file_modify_event_detection ___

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909760c80>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097acb60>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
__ ERROR at setup of TestFileMonitorService.test_file_delete_event_detection ___

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909762090>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097ada90>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
_______ ERROR at setup of TestFileMonitorService.test_monitoring_status ________

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909762240>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097ab800>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
______ ERROR at setup of TestFileMonitorService.test_ignore_hidden_files _______

self = <tests.test_file_monitoring.TestFileMonitorService object at 0x7f8909762570>
db_session = <sqlalchemy.orm.session.Session object at 0x7f89097aa780>

    @pytest.fixture
    def monitor_service(self, db_session):
        """Create a file monitor service instance."""
>       service = FileMonitorService(db_session)
E       TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given

tests/test_file_monitoring.py:34: TypeError
___________ ERROR at setup of test_folders_files_crud_and_audit_logs ___________

db_session = <sqlalchemy.orm.session.Session object at 0x7f89097ab710>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f89097a8d40>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
_________ ERROR at setup of test_logs_visibility_and_chatbot_endpoints _________

db_session = <sqlalchemy.orm.session.Session object at 0x7f89097aeb10>

    @pytest.fixture(scope="function")
    def client(db_session):
        def override_get_db():
            try:
                yield db_session
            finally:
                pass
        app.dependency_overrides[app_db.get_db] = override_get_db
    
        # Seed users
        admin = User(
            username="admin",
>           password_hash=get_password_hash("adminpass"),
            role="admin",
            created_at=datetime.now(tz=timezone.utc),
        )

tests/conftest.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/auth.py:38: in get_password_hash
    return str(pwd_context.hash(password))
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/context.py:2258: in hash
    return record.hash(secret, **kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:779: in hash
    self.checksum = self._calc_checksum(secret)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:591: in _calc_checksum
    self._stub_requires_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2254: in _stub_requires_backend
    cls.set_backend()
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2156: in set_backend
    return owner.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2163: in set_backend
    return cls.set_backend(name, dryrun=dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2188: in set_backend
    cls._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2311: in _set_backend
    super(SubclassBackendMixin, cls)._set_backend(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:2224: in _set_backend
    ok = loader(**kwds)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:626: in _load_backend_mixin
    return mixin_cls._finalize_backend_mixin(name, dryrun)
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:421: in _finalize_backend_mixin
    if detect_wrap_bug(IDENT_2A):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:380: in detect_wrap_bug
    if verify(secret, bug_hash):
/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/handlers.py:792: in verify
    return consteq(self._calc_checksum(secret), chk)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <passlib.handlers.bcrypt._BcryptBackend object at 0x7f89097aec30>
secret = b'01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345...7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234'

    def _calc_checksum(self, secret):
        # bcrypt behavior:
        #   secret must be bytes
        #   config must be ascii bytes
        #   returns ascii bytes
        secret, ident = self._prepare_digest_args(secret)
        config = self._get_config(ident)
        if isinstance(config, unicode):
            config = config.encode("ascii")
>       hash = _bcrypt.hashpw(secret, config)
E       ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])

/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py:655: ValueError
---------------------------- Captured stderr setup -----------------------------
WARNING:passlib.handlers.bcrypt:(trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
------------------------------ Captured log setup ------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
=================================== FAILURES ===================================
____________________ TestRateLimiting.test_auth_rate_limit _____________________

self = <tests.test_rate_limiting.TestRateLimiting object at 0x7f8909763020>

    def test_auth_rate_limit(self):
        """Test that auth endpoints are rate limited."""
        # Make requests up to the limit
        for i in range(5):  # AUTH_RATE_LIMIT is typically 5/minute
            response = client.post(
                "/auth/login",
                data={"username": "test", "password": "test"}
            )
            # Should get either 401 (invalid creds) or 200 (valid), but not 429
>           assert response.status_code in [200, 401, 422]
E           assert 404 in [200, 401, 422]
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/test_rate_limiting.py:23: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:app.access:request_id=34ac2516-4d0c-4cfc-b749-a519da41c514 method=POST path=/auth/login status=404 duration_ms=0.71
INFO:httpx:HTTP Request: POST http://testserver/auth/login "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     app.access:main.py:104 request_id=34ac2516-4d0c-4cfc-b749-a519da41c514 method=POST path=/auth/login status=404 duration_ms=0.71
INFO     httpx:_client.py:1026 HTTP Request: POST http://testserver/auth/login "HTTP/1.1 404 Not Found"
_________________ TestPathValidation.test_valid_absolute_path __________________

self = <tests.test_validation.TestPathValidation object at 0x7f8909763a40>

    def test_valid_absolute_path(self):
        """Test that valid absolute paths are accepted."""
>       assert validate_path("C:\\Users\\Alex\\Documents") is True
E       AssertionError: assert '/home/runner/work/Disertatie/Disertatie/backend/C:\\Users\\Alex\\Documents' is True
E        +  where '/home/runner/work/Disertatie/Disertatie/backend/C:\\Users\\Alex\\Documents' = validate_path('C:\\Users\\Alex\\Documents')

tests/test_validation.py:22: AssertionError
_________________ TestPathValidation.test_reject_relative_path _________________

self = <tests.test_validation.TestPathValidation object at 0x7f8909763cb0>

    def test_reject_relative_path(self):
        """Test that relative paths are rejected."""
        with pytest.raises(ValueError, match="must be absolute"):
>           validate_path("../documents")

tests/test_validation.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = '../documents', must_exist = False, must_be_absolute = True

    def validate_path(path: str, must_exist: bool = False, must_be_absolute: bool = True) -> str:
        """
        Validate and sanitize file/folder paths.
    
        Args:
            path: Path to validate
            must_exist: If True, path must exist on filesystem
            must_be_absolute: If True, path must be absolute
    
        Returns:
            Normalized absolute path
    
        Raises:
            ValidationError: If path is invalid or unsafe
        """
        if not path or not isinstance(path, str):
            raise ValidationError("Path must be a non-empty string")
    
        # Remove leading/trailing whitespace
        path = path.strip()
    
        # Convert to Path object for normalization
        try:
            path_obj = Path(path)
        except (ValueError, OSError) as e:
            raise ValidationError(f"Invalid path format: {e}")
    
        # Resolve to absolute path
        try:
            resolved_path = path_obj.resolve()
        except (ValueError, OSError, RuntimeError) as e:
            raise ValidationError(f"Cannot resolve path: {e}")
    
        # Check if absolute path is required
        if must_be_absolute and not resolved_path.is_absolute():
            raise ValidationError("Path must be absolute")
    
        # Prevent directory traversal attacks
        # Check for suspicious patterns
        suspicious_patterns = ['..', '~', '$', '`', ';', '|', '&', '<', '>']
        path_str = str(resolved_path)
        for pattern in suspicious_patterns:
            if pattern in path:  # Check original path
>               raise ValidationError(f"Path contains suspicious pattern: {pattern}")
E               app.services.validation.ValidationError: 400: Path contains suspicious pattern: ..

app/services/validation.py:59: ValidationError
______________ TestPathValidation.test_reject_directory_traversal ______________

self = <tests.test_validation.TestPathValidation object at 0x7f890977cf80>

    def test_reject_directory_traversal(self):
        """Test that directory traversal attempts are rejected."""
        with pytest.raises(ValueError, match="Directory traversal"):
>           validate_path("C:\\Users\\..\\..\\Windows\\System32")

tests/test_validation.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = 'C:\\Users\\..\\..\\Windows\\System32', must_exist = False
must_be_absolute = True

    def validate_path(path: str, must_exist: bool = False, must_be_absolute: bool = True) -> str:
        """
        Validate and sanitize file/folder paths.
    
        Args:
            path: Path to validate
            must_exist: If True, path must exist on filesystem
            must_be_absolute: If True, path must be absolute
    
        Returns:
            Normalized absolute path
    
        Raises:
            ValidationError: If path is invalid or unsafe
        """
        if not path or not isinstance(path, str):
            raise ValidationError("Path must be a non-empty string")
    
        # Remove leading/trailing whitespace
        path = path.strip()
    
        # Convert to Path object for normalization
        try:
            path_obj = Path(path)
        except (ValueError, OSError) as e:
            raise ValidationError(f"Invalid path format: {e}")
    
        # Resolve to absolute path
        try:
            resolved_path = path_obj.resolve()
        except (ValueError, OSError, RuntimeError) as e:
            raise ValidationError(f"Cannot resolve path: {e}")
    
        # Check if absolute path is required
        if must_be_absolute and not resolved_path.is_absolute():
            raise ValidationError("Path must be absolute")
    
        # Prevent directory traversal attacks
        # Check for suspicious patterns
        suspicious_patterns = ['..', '~', '$', '`', ';', '|', '&', '<', '>']
        path_str = str(resolved_path)
        for pattern in suspicious_patterns:
            if pattern in path:  # Check original path
>               raise ValidationError(f"Path contains suspicious pattern: {pattern}")
E               app.services.validation.ValidationError: 400: Path contains suspicious pattern: ..

app/services/validation.py:59: ValidationError
______________ TestPasswordValidation.test_valid_strong_password _______________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977d0a0>

    def test_valid_strong_password(self):
        """Test that strong passwords are accepted."""
>       assert validate_password_strength("SecurePass123!") is True
E       AssertionError: assert None is True
E        +  where None = validate_password_strength('SecurePass123!')

tests/test_validation.py:53: AssertionError
______________ TestPasswordValidation.test_reject_short_password _______________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977caa0>

    def test_reject_short_password(self):
        """Test that short passwords are rejected."""
        with pytest.raises(ValueError, match="at least 8 characters"):
>           validate_password_strength("Short1!")

tests/test_validation.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

password = 'Short1!'

    def validate_password_strength(password: str) -> None:
        """
        Validate password meets security requirements.
    
        Requirements:
        - Minimum 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        - At least one special character
    
        Raises:
            ValidationError: If password doesn't meet requirements
        """
        if not password or not isinstance(password, str):
            raise ValidationError("Password must be a non-empty string")
    
        if len(password) < 8:
>           raise ValidationError("Password must be at least 8 characters long")
E           app.services.validation.ValidationError: 400: Password must be at least 8 characters long

app/services/validation.py:114: ValidationError
_______________ TestPasswordValidation.test_reject_no_uppercase ________________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977ce00>

    def test_reject_no_uppercase(self):
        """Test that passwords without uppercase are rejected."""
        with pytest.raises(ValueError, match="uppercase letter"):
>           validate_password_strength("password123!")

tests/test_validation.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

password = 'password123!'

    def validate_password_strength(password: str) -> None:
        """
        Validate password meets security requirements.
    
        Requirements:
        - Minimum 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        - At least one special character
    
        Raises:
            ValidationError: If password doesn't meet requirements
        """
        if not password or not isinstance(password, str):
            raise ValidationError("Password must be a non-empty string")
    
        if len(password) < 8:
            raise ValidationError("Password must be at least 8 characters long")
    
        if len(password) > 128:
            raise ValidationError("Password must not exceed 128 characters")
    
        if not re.search(r'[A-Z]', password):
>           raise ValidationError("Password must contain at least one uppercase letter")
E           app.services.validation.ValidationError: 400: Password must contain at least one uppercase letter

app/services/validation.py:120: ValidationError
_______________ TestPasswordValidation.test_reject_no_lowercase ________________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977e660>

    def test_reject_no_lowercase(self):
        """Test that passwords without lowercase are rejected."""
        with pytest.raises(ValueError, match="lowercase letter"):
>           validate_password_strength("PASSWORD123!")

tests/test_validation.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

password = 'PASSWORD123!'

    def validate_password_strength(password: str) -> None:
        """
        Validate password meets security requirements.
    
        Requirements:
        - Minimum 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        - At least one special character
    
        Raises:
            ValidationError: If password doesn't meet requirements
        """
        if not password or not isinstance(password, str):
            raise ValidationError("Password must be a non-empty string")
    
        if len(password) < 8:
            raise ValidationError("Password must be at least 8 characters long")
    
        if len(password) > 128:
            raise ValidationError("Password must not exceed 128 characters")
    
        if not re.search(r'[A-Z]', password):
            raise ValidationError("Password must contain at least one uppercase letter")
    
        if not re.search(r'[a-z]', password):
>           raise ValidationError("Password must contain at least one lowercase letter")
E           app.services.validation.ValidationError: 400: Password must contain at least one lowercase letter

app/services/validation.py:123: ValidationError
_________________ TestPasswordValidation.test_reject_no_digit __________________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977e840>

    def test_reject_no_digit(self):
        """Test that passwords without digits are rejected."""
        with pytest.raises(ValueError, match="digit"):
>           validate_password_strength("Password!")

tests/test_validation.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

password = 'Password!'

    def validate_password_strength(password: str) -> None:
        """
        Validate password meets security requirements.
    
        Requirements:
        - Minimum 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        - At least one special character
    
        Raises:
            ValidationError: If password doesn't meet requirements
        """
        if not password or not isinstance(password, str):
            raise ValidationError("Password must be a non-empty string")
    
        if len(password) < 8:
            raise ValidationError("Password must be at least 8 characters long")
    
        if len(password) > 128:
            raise ValidationError("Password must not exceed 128 characters")
    
        if not re.search(r'[A-Z]', password):
            raise ValidationError("Password must contain at least one uppercase letter")
    
        if not re.search(r'[a-z]', password):
            raise ValidationError("Password must contain at least one lowercase letter")
    
        if not re.search(r'\d', password):
>           raise ValidationError("Password must contain at least one digit")
E           app.services.validation.ValidationError: 400: Password must contain at least one digit

app/services/validation.py:126: ValidationError
______________ TestPasswordValidation.test_reject_no_special_char ______________

self = <tests.test_validation.TestPasswordValidation object at 0x7f890977c980>

    def test_reject_no_special_char(self):
        """Test that passwords without special characters are rejected."""
        with pytest.raises(ValueError, match="special character"):
>           validate_password_strength("Password123")

tests/test_validation.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

password = 'Password123'

    def validate_password_strength(password: str) -> None:
        """
        Validate password meets security requirements.
    
        Requirements:
        - Minimum 8 characters
        - At least one uppercase letter
        - At least one lowercase letter
        - At least one digit
        - At least one special character
    
        Raises:
            ValidationError: If password doesn't meet requirements
        """
        if not password or not isinstance(password, str):
            raise ValidationError("Password must be a non-empty string")
    
        if len(password) < 8:
            raise ValidationError("Password must be at least 8 characters long")
    
        if len(password) > 128:
            raise ValidationError("Password must not exceed 128 characters")
    
        if not re.search(r'[A-Z]', password):
            raise ValidationError("Password must contain at least one uppercase letter")
    
        if not re.search(r'[a-z]', password):
            raise ValidationError("Password must contain at least one lowercase letter")
    
        if not re.search(r'\d', password):
            raise ValidationError("Password must contain at least one digit")
    
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
>           raise ValidationError("Password must contain at least one special character")
E           app.services.validation.ValidationError: 400: Password must contain at least one special character

app/services/validation.py:129: ValidationError
__________________ TestUsernameValidation.test_valid_username __________________

self = <tests.test_validation.TestUsernameValidation object at 0x7f890977c380>

    def test_valid_username(self):
        """Test that valid usernames are accepted."""
>       assert validate_username("admin") is True
E       AssertionError: assert 'admin' is True
E        +  where 'admin' = validate_username('admin')

tests/test_validation.py:87: AssertionError
______________ TestUsernameValidation.test_reject_short_username _______________

self = <tests.test_validation.TestUsernameValidation object at 0x7f890977c890>

    def test_reject_short_username(self):
        """Test that short usernames are rejected."""
        with pytest.raises(ValueError, match="at least 3 characters"):
>           validate_username("ab")

tests/test_validation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

username = 'ab'

    def validate_username(username: str) -> str:
        """
        Validate username format.
    
        Requirements:
        - 3-50 characters
        - Alphanumeric, underscore, hyphen only
        - Must start with letter
    
        Returns:
            Sanitized username
    
        Raises:
            ValidationError: If username is invalid
        """
        if not username or not isinstance(username, str):
            raise ValidationError("Username must be a non-empty string")
    
        username = username.strip()
    
        if len(username) < 3:
>           raise ValidationError("Username must be at least 3 characters long")
E           app.services.validation.ValidationError: 400: Username must be at least 3 characters long

app/services/validation.py:153: ValidationError
_______________ TestUsernameValidation.test_reject_long_username _______________

self = <tests.test_validation.TestUsernameValidation object at 0x7f890977c7a0>

    def test_reject_long_username(self):
        """Test that long usernames are rejected."""
        with pytest.raises(ValueError, match="at most 50 characters"):
>           validate_username("a" * 51)

tests/test_validation.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

username = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

    def validate_username(username: str) -> str:
        """
        Validate username format.
    
        Requirements:
        - 3-50 characters
        - Alphanumeric, underscore, hyphen only
        - Must start with letter
    
        Returns:
            Sanitized username
    
        Raises:
            ValidationError: If username is invalid
        """
        if not username or not isinstance(username, str):
            raise ValidationError("Username must be a non-empty string")
    
        username = username.strip()
    
        if len(username) < 3:
            raise ValidationError("Username must be at least 3 characters long")
    
        if len(username) > 50:
>           raise ValidationError("Username must not exceed 50 characters")
E           app.services.validation.ValidationError: 400: Username must not exceed 50 characters

app/services/validation.py:156: ValidationError
____________ TestUsernameValidation.test_reject_invalid_characters _____________

self = <tests.test_validation.TestUsernameValidation object at 0x7f890977fc50>

    def test_reject_invalid_characters(self):
        """Test that usernames with invalid characters are rejected."""
        with pytest.raises(ValueError, match="alphanumeric"):
>           validate_username("user@name")

tests/test_validation.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

username = 'user@name'

    def validate_username(username: str) -> str:
        """
        Validate username format.
    
        Requirements:
        - 3-50 characters
        - Alphanumeric, underscore, hyphen only
        - Must start with letter
    
        Returns:
            Sanitized username
    
        Raises:
            ValidationError: If username is invalid
        """
        if not username or not isinstance(username, str):
            raise ValidationError("Username must be a non-empty string")
    
        username = username.strip()
    
        if len(username) < 3:
            raise ValidationError("Username must be at least 3 characters long")
    
        if len(username) > 50:
            raise ValidationError("Username must not exceed 50 characters")
    
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*$', username):
>           raise ValidationError(
                "Username must start with a letter and contain only letters, numbers, underscores, and hyphens"
            )
E           app.services.validation.ValidationError: 400: Username must start with a letter and contain only letters, numbers, underscores, and hyphens

app/services/validation.py:159: ValidationError
_________________ TestStringLengthValidation.test_valid_length _________________

self = <tests.test_validation.TestStringLengthValidation object at 0x7f890977e630>

    def test_valid_length(self):
        """Test that strings within limits are accepted."""
>       assert validate_string_length("test", "field", 1, 10) is True
E       AssertionError: assert 'test' is True
E        +  where 'test' = validate_string_length('test', 'field', 1, 10)

tests/test_validation.py:114: AssertionError
_______________ TestStringLengthValidation.test_reject_too_short _______________

self = <tests.test_validation.TestStringLengthValidation object at 0x7f890977e870>

    def test_reject_too_short(self):
        """Test that strings below minimum are rejected."""
        with pytest.raises(ValueError, match="at least 5 characters"):
>           validate_string_length("hi", "field", 5, 10)

tests/test_validation.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = 'hi', field_name = 'field', min_length = 5, max_length = 10

    def validate_string_length(value: str, field_name: str, min_length: int = 1, max_length: int = 255) -> str:
        """
        Validate string length to prevent DoS attacks.
    
        Args:
            value: String to validate
            field_name: Name of the field (for error messages)
            min_length: Minimum allowed length
            max_length: Maximum allowed length
    
        Returns:
            Stripped string
    
        Raises:
            ValidationError: If string length is invalid
        """
        if not isinstance(value, str):
            raise ValidationError(f"{field_name} must be a string")
    
        value = value.strip()
    
        if len(value) < min_length:
>           raise ValidationError(f"{field_name} must be at least {min_length} characters long")
E           app.services.validation.ValidationError: 400: field must be at least 5 characters long

app/services/validation.py:188: ValidationError
_______________ TestStringLengthValidation.test_reject_too_long ________________

self = <tests.test_validation.TestStringLengthValidation object at 0x7f890977e9f0>

    def test_reject_too_long(self):
        """Test that strings above maximum are rejected."""
        with pytest.raises(ValueError, match="at most 5 characters"):
>           validate_string_length("too long string", "field", 1, 5)

tests/test_validation.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = 'too long string', field_name = 'field', min_length = 1, max_length = 5

    def validate_string_length(value: str, field_name: str, min_length: int = 1, max_length: int = 255) -> str:
        """
        Validate string length to prevent DoS attacks.
    
        Args:
            value: String to validate
            field_name: Name of the field (for error messages)
            min_length: Minimum allowed length
            max_length: Maximum allowed length
    
        Returns:
            Stripped string
    
        Raises:
            ValidationError: If string length is invalid
        """
        if not isinstance(value, str):
            raise ValidationError(f"{field_name} must be a string")
    
        value = value.strip()
    
        if len(value) < min_length:
            raise ValidationError(f"{field_name} must be at least {min_length} characters long")
    
        if len(value) > max_length:
>           raise ValidationError(f"{field_name} must not exceed {max_length} characters")
E           app.services.validation.ValidationError: 400: field must not exceed 5 characters

app/services/validation.py:191: ValidationError
________________ TestEventTypeValidation.test_valid_event_types ________________

self = <tests.test_validation.TestEventTypeValidation object at 0x7f890977ec00>

    def test_valid_event_types(self):
        """Test that valid event types are accepted."""
>       assert validate_event_type("create") is True
E       AssertionError: assert 'create' is True
E        +  where 'create' = validate_event_type('create')

tests/test_validation.py:133: AssertionError
____________ TestEventTypeValidation.test_reject_invalid_event_type ____________

self = <tests.test_validation.TestEventTypeValidation object at 0x7f890977edb0>

    def test_reject_invalid_event_type(self):
        """Test that invalid event types are rejected."""
        with pytest.raises(ValueError, match="Invalid event_type"):
>           validate_event_type("invalid")

tests/test_validation.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

event_type = 'invalid'

    def validate_event_type(event_type: str) -> str:
        """
        Validate event type is one of the allowed values.
    
        Allowed: create, modify, delete
    
        Returns:
            Lowercase event type
    
        Raises:
            ValidationError: If event type is invalid
        """
        if not event_type or not isinstance(event_type, str):
            raise ValidationError("Event type must be a non-empty string")
    
        event_type = event_type.strip().lower()
    
        allowed_types = {'create', 'modify', 'delete'}
        if event_type not in allowed_types:
>           raise ValidationError(f"Event type must be one of: {', '.join(allowed_types)}")
E           app.services.validation.ValidationError: 400: Event type must be one of: create, delete, modify

app/services/validation.py:215: ValidationError
____________ TestSeverityLevelValidation.test_valid_severity_levels ____________

self = <tests.test_validation.TestSeverityLevelValidation object at 0x7f890977f050>

    def test_valid_severity_levels(self):
        """Test that valid severity levels are accepted."""
>       assert validate_severity_level("Low") is True
E       AssertionError: assert 'Low' is True
E        +  where 'Low' = validate_severity_level('Low')

tests/test_validation.py:150: AssertionError
___________ TestSeverityLevelValidation.test_reject_invalid_severity ___________

self = <tests.test_validation.TestSeverityLevelValidation object at 0x7f890977ee10>

    def test_reject_invalid_severity(self):
        """Test that invalid severity levels are rejected."""
        with pytest.raises(ValueError, match="Invalid severity_level"):
>           validate_severity_level("Extreme")

tests/test_validation.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

severity = 'Extreme'

    def validate_severity_level(severity: str) -> str:
        """
        Validate severity level is one of the allowed values.
    
        Allowed: Low, Medium, High, Critical
    
        Returns:
            Capitalized severity level
    
        Raises:
            ValidationError: If severity is invalid
        """
        if not severity or not isinstance(severity, str):
            raise ValidationError("Severity level must be a non-empty string")
    
        severity = severity.strip().capitalize()
    
        allowed_levels = {'Low', 'Medium', 'High', 'Critical'}
        if severity not in allowed_levels:
>           raise ValidationError(f"Severity level must be one of: {', '.join(allowed_levels)}")
E           app.services.validation.ValidationError: 400: Severity level must be one of: Medium, Low, High, Critical

app/services/validation.py:239: ValidationError
_____________________ TestRoleValidation.test_valid_roles ______________________

self = <tests.test_validation.TestRoleValidation object at 0x7f890977eba0>

    def test_valid_roles(self):
        """Test that valid roles are accepted."""
>       assert validate_role("admin") is True
E       AssertionError: assert 'admin' is True
E        +  where 'admin' = validate_role('admin')

tests/test_validation.py:168: AssertionError
_________________ TestRoleValidation.test_reject_invalid_role __________________

self = <tests.test_validation.TestRoleValidation object at 0x7f890977e600>

    def test_reject_invalid_role(self):
        """Test that invalid roles are rejected."""
        with pytest.raises(ValueError, match="Invalid role"):
>           validate_role("superuser")

tests/test_validation.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

role = 'superuser'

    def validate_role(role: str) -> str:
        """
        Validate user role is one of the allowed values.
    
        Allowed: admin, user
    
        Returns:
            Lowercase role
    
        Raises:
            ValidationError: If role is invalid
        """
        if not role or not isinstance(role, str):
            raise ValidationError("Role must be a non-empty string")
    
        role = role.strip().lower()
    
        allowed_roles = {'admin', 'user'}
        if role not in allowed_roles:
>           raise ValidationError(f"Role must be one of: {', '.join(allowed_roles)}")
E           app.services.validation.ValidationError: 400: Role must be one of: user, admin

app/services/validation.py:263: ValidationError
=============================== warnings summary ===============================
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/__init__.py:854
  /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/passlib/utils/__init__.py:854: DeprecationWarning: 'crypt' is deprecated and slated for removal in Python 3.13
    from crypt import crypt as _crypt

../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
../../../../../../opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
  /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pydantic/_internal/_config.py:291: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.8/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_rate_limiting.py::TestRateLimiting::test_auth_rate_limit - assert 404 in [200, 401, 422]
 +  where 404 = <Response [404 Not Found]>.status_code
FAILED tests/test_validation.py::TestPathValidation::test_valid_absolute_path - AssertionError: assert '/home/runner/work/Disertatie/Disertatie/backend/C:\\Users\\Alex\\Documents' is True
 +  where '/home/runner/work/Disertatie/Disertatie/backend/C:\\Users\\Alex\\Documents' = validate_path('C:\\Users\\Alex\\Documents')
FAILED tests/test_validation.py::TestPathValidation::test_reject_relative_path - app.services.validation.ValidationError: 400: Path contains suspicious pattern: ..
FAILED tests/test_validation.py::TestPathValidation::test_reject_directory_traversal - app.services.validation.ValidationError: 400: Path contains suspicious pattern: ..
FAILED tests/test_validation.py::TestPasswordValidation::test_valid_strong_password - AssertionError: assert None is True
 +  where None = validate_password_strength('SecurePass123!')
FAILED tests/test_validation.py::TestPasswordValidation::test_reject_short_password - app.services.validation.ValidationError: 400: Password must be at least 8 characters long
FAILED tests/test_validation.py::TestPasswordValidation::test_reject_no_uppercase - app.services.validation.ValidationError: 400: Password must contain at least one uppercase letter
FAILED tests/test_validation.py::TestPasswordValidation::test_reject_no_lowercase - app.services.validation.ValidationError: 400: Password must contain at least one lowercase letter
FAILED tests/test_validation.py::TestPasswordValidation::test_reject_no_digit - app.services.validation.ValidationError: 400: Password must contain at least one digit
FAILED tests/test_validation.py::TestPasswordValidation::test_reject_no_special_char - app.services.validation.ValidationError: 400: Password must contain at least one special character
FAILED tests/test_validation.py::TestUsernameValidation::test_valid_username - AssertionError: assert 'admin' is True
 +  where 'admin' = validate_username('admin')
FAILED tests/test_validation.py::TestUsernameValidation::test_reject_short_username - app.services.validation.ValidationError: 400: Username must be at least 3 characters long
FAILED tests/test_validation.py::TestUsernameValidation::test_reject_long_username - app.services.validation.ValidationError: 400: Username must not exceed 50 characters
FAILED tests/test_validation.py::TestUsernameValidation::test_reject_invalid_characters - app.services.validation.ValidationError: 400: Username must start with a letter and contain only letters, numbers, underscores, and hyphens
FAILED tests/test_validation.py::TestStringLengthValidation::test_valid_length - AssertionError: assert 'test' is True
 +  where 'test' = validate_string_length('test', 'field', 1, 10)
FAILED tests/test_validation.py::TestStringLengthValidation::test_reject_too_short - app.services.validation.ValidationError: 400: field must be at least 5 characters long
FAILED tests/test_validation.py::TestStringLengthValidation::test_reject_too_long - app.services.validation.ValidationError: 400: field must not exceed 5 characters
FAILED tests/test_validation.py::TestEventTypeValidation::test_valid_event_types - AssertionError: assert 'create' is True
 +  where 'create' = validate_event_type('create')
FAILED tests/test_validation.py::TestEventTypeValidation::test_reject_invalid_event_type - app.services.validation.ValidationError: 400: Event type must be one of: create, delete, modify
FAILED tests/test_validation.py::TestSeverityLevelValidation::test_valid_severity_levels - AssertionError: assert 'Low' is True
 +  where 'Low' = validate_severity_level('Low')
FAILED tests/test_validation.py::TestSeverityLevelValidation::test_reject_invalid_severity - app.services.validation.ValidationError: 400: Severity level must be one of: Medium, Low, High, Critical
FAILED tests/test_validation.py::TestRoleValidation::test_valid_roles - AssertionError: assert 'admin' is True
 +  where 'admin' = validate_role('admin')
FAILED tests/test_validation.py::TestRoleValidation::test_reject_invalid_role - app.services.validation.ValidationError: 400: Role must be one of: user, admin
ERROR tests/test_ai_rules_feedback.py::test_ai_rules_crud_admin_only_and_feedback - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
ERROR tests/test_auth.py::test_login_and_me - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
ERROR tests/test_escalation.py::test_escalation_runs_via_background_tasks - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
ERROR tests/test_events_ai.py::test_event_triggers_ai_and_notify_log - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_service_initialization - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_service_start_stop - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_add_folder_to_monitoring - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_remove_folder_from_monitoring - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_file_create_event_detection - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_file_modify_event_detection - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_file_delete_event_detection - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_monitoring_status - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_file_monitoring.py::TestFileMonitorService::test_ignore_hidden_files - TypeError: FileMonitorService.__init__() takes 1 positional argument but 2 were given
ERROR tests/test_folders_files.py::test_folders_files_crud_and_audit_logs - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
ERROR tests/test_logs_and_chatbot.py::test_logs_visibility_and_chatbot_endpoints - ValueError: password cannot be longer than 72 bytes, truncate manually if necessary (e.g. my_password[:72])
23 failed, 8 passed, 8 warnings, 15 errors in 1.30s
Error: Process completed with exit code 1.